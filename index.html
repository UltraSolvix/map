<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ø®Ø±ÙŠØ·Ø© Ø°ÙƒÙŠØ© â€” ØªØªØ¨Ø¹ Ùˆ Ù…Ø³Ø§Ø± ØªÙØ§Ø¹Ù„ÙŠ</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css"/>

<style>
  :root{ --accent:#007bff; --green:#28a745; --red:#dc3545; }
  html,body{height:100%;margin:0;font-family: "Cairo", sans-serif; background:#f4f6f9;}
  #controls{
    background: linear-gradient(135deg,var(--accent), #0056b3);
    color:#fff;padding:12px;box-shadow:0 4px 12px rgba(0,0,0,0.12);z-index:1200;
    display:flex;gap:8px;align-items:center;flex-wrap:wrap;position:relative;
  }
  .input-group{ display:flex;flex-direction:column; width:280px; position:relative; }
  input{ padding:10px 12px;border-radius:8px;border:none;font-size:15px; }
  button{ padding:10px 14px;border-radius:8px;border:none;background:#fff;color:var(--accent);font-weight:700;cursor:pointer; }
  #map{ height:calc(100vh - 120px); width:100%; }
  #location{ position:absolute; top:14px; left:14px; background:rgba(255,255,255,0.85); padding:8px 12px; border-radius:10px; z-index:1300; max-width:46%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
  #status{ position:absolute; left:14px; bottom:14px; background:rgba(255,255,255,0.95); padding:6px 10px;border-radius:8px; z-index:1300; font-size:13px; }
  .suggestions{ position:absolute; top:42px; left:0; right:0; background:#fff;border-radius:0 0 8px 8px;border:1px solid rgba(0,0,0,0.08); max-height:180px; overflow:auto; z-index:1400; display:none; }
  .suggestions div{ padding:8px 10px; cursor:pointer; border-bottom:1px solid #f2f2f2; }
  .suggestions div:hover{ background:#e9f3ff; }
  .controls-right{ margin-right:auto; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  @media(max-width:700px){
    .input-group{ width:44vw; }
    #location{ max-width:60%; font-size:14px; }
  }
</style>
</head>
<body>

<div id="controls">
  <div class="controls-right">
    <div style="font-weight:800;font-size:18px">ğŸš— Ø®Ø±ÙŠØ·ØªÙƒ Ø§Ù„Ø°ÙƒÙŠØ©</div>
    <div style="color:#dbe9ff;font-size:13px">Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§Ù† Ø£Ùˆ Ø§Ø®ØªØ± "Ù…ÙˆÙ‚Ø¹ÙŠ"</div>
  </div>

  <div class="input-group">
    <input id="start" placeholder="Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ø£Ùˆ Ø§Ø¶ØºØ· Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙˆÙ‚Ø¹ÙŠ)" autocomplete="off">
    <div id="start-suggestions" class="suggestions"></div>
  </div>

  <div class="input-group">
    <input id="end" placeholder="Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©" autocomplete="off">
    <div id="end-suggestions" class="suggestions"></div>
  </div>

  <button id="use-my-pos">Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙˆÙ‚Ø¹ÙŠ ÙƒØ¨Ø¯Ø§ÙŠØ©</button>
  <button id="compute">ØªÙ… â€” Ø§Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±</button>
</div>

<div id="location">Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: <strong id="address">Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹...</strong></div>
<div id="map"></div>
<div id="status">Ø­Ø§Ù„Ø©: Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹ â€” Ø¯Ù‚Ø© Ù…Ø³ØªÙ‡Ø¯ÙØ© â‰¤ 5 Ù…</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>

<script>
/* =================== Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ùˆ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª =================== */
const map = L.map('map', { zoomControl: true }).setView([26.8206, 30.8025], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

const statusEl = document.getElementById('status');
const addressEl = document.getElementById('address');
const startInput = document.getElementById('start');
const endInput = document.getElementById('end');
const startSug = document.getElementById('start-suggestions');
const endSug = document.getElementById('end-suggestions');
const useMyPosBtn = document.getElementById('use-my-pos');
const computeBtn = document.getElementById('compute');

let routingControl = null;
let routeLine = null;         // ÙƒØ§Ù…Ù„ Ø§Ù„Ù…Ø³Ø§Ø± (Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ù„ÙˆÙ† Ø£Ø­Ù…Ø± Ø¨Ø¹Ø¯ Ø§Ù„ØªÙ‚Ø³ÙŠÙ…)
let traveledLine = null;      // Ø§Ù„Ø¬Ø²Ø¡ Ø§Ù„Ø°ÙŠ Ø§Ø¬ØªØ²ØªÙ‡ (Ù„ÙˆÙ† Ù…Ø®ØªÙ„Ù)
let routeCoords = [];         // Ù…ØµÙÙˆÙØ© Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª (lat,lng) Ù„Ù„Ù…Ø³Ø§Ø±
let routeDistMeters = 0;      // Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø± Ø¨Ø§Ù„Ø£Ù…ØªØ§Ø±

/* ØªØªØ¨Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… */
let lastPos = null;           // Ø¢Ø®Ø± Ù…ÙˆØ¶Ø¹ Ù†Ù‡Ø§Ø¦ÙŠ
let nextPos = null;           // Ù…ØªØºÙŠØ± Ù„Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø§Ù†Ø³ÙŠØ§Ø¨ÙŠØ©
let marker = null;
let autoCenter = true;
const POLL_INTERVAL_MS = 1000;
const TARGET_ACCURACY_M = 5;
const REVERSE_MIN_MOVE = 3; // Ù…ØªØ±: ÙƒÙ„Ù…Ø§ ØªØ­Ø±ÙƒØª Ø£ÙƒØ«Ø± Ù…Ù† Ù‡Ø°Ø§ Ù†Ø¹Ù…Ù„ reverse geocode

/* ======== Ø¯ÙˆØ§Ù„ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø±ÙŠØ§Ø¶ÙŠØ© ======== */
function toRad(v){ return v * Math.PI/180; }
function haversineMeters(a,b){
  const R=6371000;
  const dLat = toRad(b.lat-a.lat), dLon = toRad(b.lng-a.lng);
  const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
  const A = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return R * 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
}
// ØªÙ‚Ø±ÙŠØ¨ ØªØ­ÙˆÙŠÙ„ Ø¯Ø±Ø¬ØªÙŠÙ† -> Ø£Ù…ØªØ§Ø± (ØªÙ‚Ø±ÙŠØ¨ Ù…ÙÙŠØ¯ Ù„Ù„Ù…Ø³Ù‚Ø· Ø§Ù„Ø¹Ø±Ø¶ÙŠ)
function latLonToXY(lat,lng, refLat){
  const x = lng * 111320 * Math.cos(toRad(refLat));
  const y = lat * 110540;
  return {x,y};
}
/* Ù…Ø´Ø±ÙˆØ¹ Ø§Ù„Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ù‚Ø·Ø¹Ø© (A->B) ÙˆØ§Ø±Ø¬Ø§Ø¹ t (0..1) */
function projectPointOnSegment(p, A, B, refLat){
  const pXY = latLonToXY(p.lat,p.lng, refLat);
  const AXY = latLonToXY(A.lat,A.lng, refLat);
  const BXY = latLonToXY(B.lat,B.lng, refLat);
  const vx = BXY.x - AXY.x, vy = BXY.y - AXY.y;
  const wx = pXY.x - AXY.x, wy = pXY.y - AXY.y;
  const denom = vx*vx + vy*vy;
  if (denom === 0) return {t:0, closest: A, dist: haversineMeters(p,A)};
  let t = (vx*wx + vy*wy) / denom;
  if (t < 0) t = 0; if (t > 1) t = 1;
  const cx = AXY.x + vx*t, cy = AXY.y + vy*t;
  // ØªØ­ÙˆÙŠÙ„ Ù…Ø±Ø© Ø§Ø®Ø±Ù‰ ØªÙ‚Ø±ÙŠØ¨Ø§ -> lat/lng (Ø¹ÙƒØ³ ØªÙ‚Ø±ÙŠØ¨)
  // Ù†Ø³ØªØ®Ø¯Ù… ØªÙ‚Ø¯ÙŠØ± ØµØºÙŠØ±: delta deg = meters / meters-per-degree
  const lat = (cy / 110540);
  const lng = (cx / (111320 * Math.cos(toRad(refLat))));
  const closest = { lat, lng };
  const dist = haversineMeters(p, closest);
  return { t, closest, dist };
}

/* =================== Reverse Geocode (Ø§Ø³Ù… Ø§Ù„Ø´Ø§Ø±Ø¹) =================== */
let lastReverse = null;
async function reverseGeocodeIfNeeded(lat, lon){
  try{
    if (lastReverse && haversineMeters(lastReverse, {lat, lng: lon}) <= REVERSE_MIN_MOVE) return;
    lastReverse = {lat, lng: lon};
    addressEl.textContent = 'Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ø´Ø§Ø±Ø¹...';
    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=20&addressdetails=1&accept-language=ar`;
    const res = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' }});
    if (!res.ok) throw new Error('Ø®Ø·Ø£ ÙÙŠ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù†ÙˆØ§Ù†');
    const data = await res.json();
    const addr = data.address || {};
    const street = addr.road || addr.pedestrian || addr.highway || addr.suburb || addr.village || addr.town || '';
    let name = street || data.display_name || 'Ù…ÙˆÙ‚Ø¹ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
    if (name.length > 80) name = name.slice(0,80) + '...';
    addressEl.textContent = name;
  }catch(e){
    console.error(e);
    addressEl.textContent = 'Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ø´Ø§Ø±Ø¹';
  }
}

/* =================== Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ø§Ù„Ø¨Ø­Ø« (Nominatim) =================== */
async function fetchSuggestions(query, box){
  if (!query || query.trim().length < 2){ box.style.display='none'; box.innerHTML = ''; return; }
  try{
    const q = query.includes('Ù…ØµØ±') ? query : `${query}, Ù…ØµØ±`;
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&countrycodes=eg&limit=7&accept-language=ar`;
    const res = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' }});
    const data = await res.json();
    box.innerHTML = '';
    if (!data || data.length===0){ box.style.display='none'; return; }
    data.forEach(p=>{
      const div = document.createElement('div');
      const display = p.display_name.split(',').slice(0,3).join(', ');
      div.textContent = display;
      div.title = p.display_name;
      div.onclick = ()=>{ 
        // Ø¶Ø¹ Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„ÙƒØ§Ù…Ù„Ø© ÙˆØ§Ù„Ù†Øµ Ù…Ù†Ø³Ù‚
        const input = box.previousElementSibling;
        input.value = p.display_name;
        input.dataset.lat = p.lat;
        input.dataset.lon = p.lon;
        box.style.display='none';
      };
      box.appendChild(div);
    });
    box.style.display = 'block';
  }catch(err){
    console.error('suggestions',err);
    box.style.display='none';
  }
}
function setupSuggestions(inp, box){
  let to;
  inp.addEventListener('input', e=>{
    clearTimeout(to);
    to = setTimeout(()=> fetchSuggestions(e.target.value, box), 300);
  });
  inp.addEventListener('focus', ()=>{ if (inp.value.length>=2) fetchSuggestions(inp.value, box); });
  document.addEventListener('click', e=>{
    if (!inp.contains(e.target) && !box.contains(e.target)) box.style.display='none';
  });
}
setupSuggestions(startInput, startSug);
setupSuggestions(endInput, endSug);

/* ============== Geocoding Ø¨Ø³ÙŠØ· (Ù„Ù€ compute) ============== */
async function geocodeOne(place){
  // Ø¥Ø°Ø§ Ø§Ù„Ø­Ù‚Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹ ÙŠØ­ØªÙˆÙŠ lat/lon ÙÙŠ dataset Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§
  if (!place || !place.trim()) throw new Error('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù…ÙƒØ§Ù†');
  // Ù„Ùˆ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø£Ø¯Ø®Ù„ display name Ø³Ø§Ø¨Ù‚Ø§Ù‹ Ù…Ø¹ lat/lon Ù…Ø®Ø²Ù†Ø©
  // (Ù†Ø¨Ø­Ø« Ø£ÙˆÙ„Ø§Ù‹ ÙÙŠ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø¹Ø±ÙˆÙØ©)
  // ÙˆØ¥Ù„Ø§ Ù†Ø·Ù„Ø¨ Ù…Ù† Nominatim
  const q = place.includes('Ù…ØµØ±') ? place : `${place}, Ù…ØµØ±`;
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(q)}&countrycodes=eg&limit=1&accept-language=ar`;
  const res = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' }});
  const data = await res.json();
  if (!data || data.length===0) throw new Error(`ØªØ¹Ø°Ø± Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰: ${place}`);
  return { lat: parseFloat(data[0].lat), lng: parseFloat(data[0].lon), name: data[0].display_name };
}

/* =================== Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø± (OSRM Ø¹Ø¨Ø± Leaflet Routing Machine) =================== */
function clearRouteVisualization(){
  if (routingControl) { map.removeControl(routingControl); routingControl = null; }
  if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
  if (traveledLine) { map.removeLayer(traveledLine); traveledLine = null; }
  routeCoords = []; routeDistMeters = 0;
}
async function computeRoute(startLatLng, endLatLng){
  try{
    statusEl.textContent = 'â³ Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„ Ù…Ø³Ø§Ø±...';
    clearRouteVisualization();

    routingControl = L.Routing.control({
      waypoints: [ L.latLng(startLatLng.lat, startLatLng.lng), L.latLng(endLatLng.lat, endLatLng.lng) ],
      router: L.Routing.osrmv1({ serviceUrl: 'https://router.project-osrm.org/route/v1/' }),
      lineOptions: { styles: [{ color: '#ff0000', weight: 6, opacity: 0.9 }] },
      addWaypoints: false, draggableWaypoints: false, fitSelectedRoutes: true, showAlternatives: false,
      createMarker: function() { return null; }
    }).addTo(map);

    routingControl.on('routesfound', e=>{
      const route = e.routes[0];
      // Ø¬Ù…Ø¹ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙÙŠ Ù…ØµÙÙˆÙØ© (lat,lng)
      routeCoords = route.coordinates.map(c => ({ lat: c.lat, lng: c.lng }));
      // Ø·ÙˆÙ„ Ø§Ù„Ù…Ø³Ø§Ø± Ø¨Ø§Ù„Ø£Ù…ØªØ§Ø±
      routeDistMeters = route.summary.totalDistance;
      // Ø±Ø³Ù… Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„ÙƒØ§Ù…Ù„ (Ø³ÙŠØªÙ… ØªÙ‚Ø³ÙŠÙ…Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹)
      if (routeLine) map.removeLayer(routeLine);
      routeLine = L.polyline(routeCoords, { color: '#ff0000', weight:6, opacity:0.9 }).addTo(map);
      statusEl.innerHTML = `âœ… Ø§Ù„Ù…Ø³Ø§ÙØ©: ${(routeDistMeters/1000).toFixed(1)} ÙƒÙ… â€” Ø§Ù„Ø²Ù…Ù† Ø§Ù„Ù…ØªÙˆÙ‚Ø¹: ${Math.round(route.summary.totalTime/60)} Ø¯`;
      // Ø£Ø¹Ø¯ Ø­Ø³Ø§Ø¨ Ø§Ù„ØªÙ‚Ø¯Ù… (Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ù…ÙˆØ¶Ø¹ Ø­Ø§Ù„ÙŠ)
      if (lastPos) updateProgress({ lat:lastPos.lat, lng:lastPos.lng });
      // Ø¥Ø®ÙØ§Ø¡ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ¹Ù„ÙŠÙ…Ø§Øª Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
      setTimeout(()=>{ document.querySelectorAll('.leaflet-routing-container').forEach(n=>n.remove()); }, 80);
    });

    routingControl.on('routingerror', ()=>{ statusEl.textContent = 'âŒ Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±'; });
  }catch(err){
    console.error(err);
    statusEl.textContent = `âŒ Ø®Ø·Ø£: ${err.message}`;
  }
}

/* ============ ØªÙ‚Ø³ÙŠÙ… Ø§Ù„Ù…Ø³Ø§Ø± Ø¥Ù„Ù‰ 'ØªÙ‚Ø¯Ù…' Ùˆ 'Ù…ØªØ¨Ù‚ÙŠ' Ø¨Ù†Ø§Ø¡ Ø¹Ù„Ù‰ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ============ */
function updateProgress(pos){
  // pos: {lat,lng}
  if (!routeCoords || routeCoords.length < 2) {
    // Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³Ø§Ø±
    // ÙÙ‚Ø· Ø­Ø¯Ù‘Ø« marker ÙˆØ§Ø³Ù… Ø§Ù„Ø´Ø§Ø±Ø¹
    placeOrUpdateMarker(pos.lat,pos.lng);
    reverseGeocodeIfNeeded(pos.lat,pos.lng);
    return;
  }

  // Ù†Ø­Ø¯Ø¯ Ù…Ø±Ø¬Ø¹ Ø¹Ø±Ø¶ Ù…ØªÙˆØ³Ø· Ù„Ù„Ù…Ø³Ù‚Ø·
  const refLat = pos.lat;

  // Ù†Ù…Ø± Ø¹Ù„Ù‰ ÙƒÙ„ Ù‚Ø·Ø¹Ø© ÙˆÙ†Ø­Ø³Ø¨ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø©
  let best = { segIndex: 0, t:0, dist: Infinity, projected: null, accDistToProjected: 0 };
  let accDist = 0;
  for (let i=0;i<routeCoords.length-1;i++){
    const A = routeCoords[i], B = routeCoords[i+1];
    const proj = projectPointOnSegment(pos, A, B, refLat);
    // Ø§Ù„Ù…Ø³Ø§ÙØ© Ù…Ù† A Ø­ØªÙ‰ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¥Ø³Ù‚Ø§Ø· (Ø¨Ø­Ø³Ø§Ø¨ Ø·ÙˆÙ„ Ø§Ù„Ø£Ø¬Ø²Ø§Ø¡ Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© + t * segmentLength)
    const segLen = haversineMeters(A, B);
    const distFromStartToProj = accDist + segLen * proj.t;
    if (proj.dist < best.dist){
      best = { segIndex:i, t:proj.t, dist:proj.dist, projected: proj.closest, accDistToProjected: distFromStartToProj };
    }
    accDist += segLen;
  }

  // Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø¬Ø²Ø¦ÙŠÙ†: traveledCoords = routeCoords[0..segIndex] + projected ; remaining = projected + routeCoords[segIndex+1 .. end]
  const traveledCoords = [];
  for (let i=0;i<=best.segIndex;i++) traveledCoords.push([routeCoords[i].lat, routeCoords[i].lng]);
  // Ø£Ø¶Ù Ø§Ù„Ù†Ù‚Ø·Ø© Ø§Ù„Ù…Ø³Ù‚Ø·Ø© ÙƒØ¢Ø®Ø± Ù†Ù‚Ø·Ø© ÙÙŠ traveled
  traveledCoords.push([best.projected.lat, best.projected.lng]);

  const remainingCoords = [];
  remainingCoords.push([best.projected.lat, best.projected.lng]);
  for (let i=best.segIndex+1;i<routeCoords.length;i++) remainingCoords.push([routeCoords[i].lat, routeCoords[i].lng]);

  // ØªØ­Ø¯ÙŠØ«/Ø¥Ø¹Ø§Ø¯Ø© Ø±Ø³Ù… Ø®Ø·ÙˆØ· traveled Ùˆ remaining
  if (traveledLine) { map.removeLayer(traveledLine); traveledLine = null; }
  if (routeLine) { map.removeLayer(routeLine); routeLine = null; }

  traveledLine = L.polyline(traveledCoords, { color: '#20c997', weight:6, opacity:0.95 }).addTo(map);
  routeLine = L.polyline(remainingCoords, { color: '#ff4d4d', weight:6, opacity:0.9 }).addTo(map);

  // Ø¶Ø¹ marker Ø¹Ù„Ù‰ Ù…ÙˆØ¶Ø¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  placeOrUpdateMarker(pos.lat, pos.lng);

  // Ù„Ùˆ autCenter Ù…ÙØ¹Ù„ Ù†Ø±ÙƒØ² Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  if (autoCenter) map.setView([pos.lat,pos.lng], Math.max(14, map.getZoom()), { animate:true, pan:{ duration:0.6 } });

  // Ø­Ø¯Ù‘Ø« status Ø¨Ù…Ø³Ø§ÙØ© Ù…ØªØ¨Ù‚ÙŠØ© ÙˆÙ…Ù‚Ø·ÙˆØ¹Ø©
  const metersTraveled = best.accDistToProjected;
  const metersRemaining = Math.max(0, routeDistMeters - metersTraveled);
  statusEl.innerHTML = `ğŸŸ¢ ØªÙ…: ${(metersTraveled/1000).toFixed(2)} ÙƒÙ… â€” ğŸ”´ Ù…ØªØ¨Ù‚ÙŠ: ${(metersRemaining/1000).toFixed(2)} ÙƒÙ…`;
}

/* =================== Ù…Ø¤Ø´Ø± Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… =================== */
function placeOrUpdateMarker(lat, lng){
  if (!marker) { marker = L.circleMarker([lat,lng], { radius:8, color:'#0078ff', weight:2, fillOpacity:1 }).addTo(map); }
  else marker.setLatLng([lat,lng]);
}

/* =================== ØªØªØ¨Ø¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹: watchPosition + poll Ø§Ø­ØªÙŠØ§Ø·ÙŠ ================ */
function handleNewGPS(lat, lng, accuracy){
  lastPos = { lat, lng, accuracy, time: Date.now() };
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¯Ù‚Ø© ÙÙŠ Ø§Ù„ status
  statusEl.textContent = `Ø¯Ù‚Ø©: ${Math.round(accuracy)} Ù… â€” Ù…Ø³ØªÙ‡Ø¯ÙØ© â‰¤ ${TARGET_ACCURACY_M} Ù…`;
  reverseGeocodeIfNeeded(lat, lng);
  // ÙÙŠ ÙƒÙ„ ØªØ­Ø¯ÙŠØ« Ù†Ø­Ø¯Ø« Ø§Ù„ØªÙ‚Ø¯Ù… Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±
  updateProgress({ lat, lng });
}

let watchId = null;
function startTracking(){
  if (!('geolocation' in navigator)){ statusEl.textContent = 'Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹'; return; }
  try{
    watchId = navigator.geolocation.watchPosition(pos=>{
      const { latitude, longitude, accuracy } = pos.coords;
      handleNewGPS(latitude, longitude, accuracy);
    }, err=>{
      console.error('watch err',err);
      statusEl.textContent = 'ØªØ¹Ø°Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ (ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­)';
    }, { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
  }catch(e){ console.error(e); }

  // poll Ø§Ø­ØªÙŠØ§Ø·ÙŠ ÙƒÙ„ Ø«Ø§Ù†ÙŠØ©
  setInterval(()=>{
    navigator.geolocation.getCurrentPosition(pos=>{
      const { latitude, longitude, accuracy } = pos.coords;
      handleNewGPS(latitude, longitude, accuracy);
    }, ()=>{/* ignore */}, { enableHighAccuracy:true, maximumAge:0, timeout:5000 });
  }, POLL_INTERVAL_MS);
}

/* =================== ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« UI =================== */
useMyPosBtn.addEventListener('click', ()=>{
  if (!lastPos) { alert('Ø§Ù†ØªØ¸Ø± ØªØ­Ø¯ÙŠØ¯ Ù…ÙˆÙ‚Ø¹Ùƒ Ø£ÙˆÙ„Ø§Ù‹'); return; }
  // Ø¶Ø¹ Ù†Øµ ÙˆØ§Ø¶Ø­ ÙÙŠ Ø­Ù‚Ù„ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©
  startInput.value = 'Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ';
  // Ø®Ø²Ù‘Ù† Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª ÙÙŠ dataset Ù„ØªØ¬Ù†Ù‘ÙØ¨ geocoding Ù„Ø§Ø­Ù‚
  startInput.dataset.lat = lastPos.lat;
  startInput.dataset.lon = lastPos.lng;
  // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù‚ØµÙŠØ± Ù„Ø§Ø³Ù… Ø§Ù„Ù…ÙˆÙ‚Ø¹
  startInput.title = addressEl.textContent || '';
});

computeBtn.addEventListener('click', async ()=>{
  try{
    let startVal = startInput.value.trim();
    let endVal = endInput.value.trim();
    if (!startVal || !endVal) { alert('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ©'); return; }

    // Ù„Ùˆ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© Ù…ÙƒØªÙˆØ¨Ø© "Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ" Ø£Ùˆ Ù„Ø¯ÙŠÙ‡Ø§ lat/lon Ù…Ø®Ø²Ù†Ø© ÙÙŠ dataset Ø§Ø³ØªØ®Ø¯Ù…Ù‡Ø§
    let startLatLng;
    if (startInput.dataset.lat && startInput.dataset.lon){
      startLatLng = { lat: parseFloat(startInput.dataset.lat), lng: parseFloat(startInput.dataset.lon) };
    } else if (startVal === 'Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ' && lastPos){
      startLatLng = { lat:lastPos.lat, lng:lastPos.lng };
    } else {
      // geocode
      statusEl.textContent = 'â³ Ø¬Ù„Ø¨ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©...';
      startLatLng = await geocodeOne(startVal);
    }

    statusEl.textContent = 'â³ Ø¬Ù„Ø¨ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©...';
    const endLatLng = await geocodeOne(endVal);

    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±
    await computeRoute(startLatLng, endLatLng);
  }catch(err){
    console.error(err);
    alert(err.message || 'Ø­Ø¯Ø« Ø®Ø·Ø£');
    statusEl.textContent = 'Ø­Ø§Ù„Ø©: Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø­Ø³Ø§Ø¨';
  }
});

/* Ù…Ù†Ø¹ submit Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¹Ù„Ù‰ Enter Ø¯Ø§Ø®Ù„ Ø§Ù„Ø­Ù‚ÙˆÙ„ */
[startInput, endInput].forEach(inp=>{
  inp.addEventListener('keypress', e=>{ if (e.key === 'Enter') e.preventDefault(); });
});

/* ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª */
startInput.addEventListener('input', ()=>{ delete startInput.dataset.lat; delete startInput.dataset.lon; });
endInput.addEventListener('input', ()=>{ delete endInput.dataset.lat; delete endInput.dataset.lon; });

/* Ø¨Ø­Ø« Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª Ù…Ø­Ù„ÙŠØ§Ù‹ */
let startTimeout, endTimeout;
startInput.addEventListener('input', e=>{ clearTimeout(startTimeout); startTimeout = setTimeout(()=> fetchSuggestions(e.target.value, startSug), 300); });
endInput.addEventListener('input', e=>{ clearTimeout(endTimeout); endTimeout = setTimeout(()=> fetchSuggestions(e.target.value, endSug), 300); });

/* =================== ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø¹Ù†Ø¯ ØªÙØ§Ø¹Ù„ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… =================== */
map.on('movestart', ()=>{ autoCenter = false; });
map.on('click', ()=>{ autoCenter = false; });

/* Ø§Ø¨Ø¯Ø£ Ø§Ù„ØªØªØ¨Ø¹ ÙÙˆØ± Ø§Ù„ØªØ­Ù…ÙŠÙ„ */
startTracking();

/* ÙˆØ¶Ø¹ Ø§Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø£ÙˆÙ„ÙŠ */
map.whenReady(()=> statusEl.textContent = 'ğŸŒ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø¬Ø§Ù‡Ø²Ø© â€” Ø§Ù†ØªØ¸Ø± ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹...');

</script>
</body>
</html>
