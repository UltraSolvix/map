<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø®Ø±ÙŠØ·Ø© Ù…ØµØ± Ø§Ù„Ø°ÙƒÙŠØ© - ØªØªØ¨Ø¹ Ø¯Ù‚ÙŠÙ‚ ÙˆØªØ®Ø·ÙŠØ· Ù…Ø³Ø§Ø±</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
    <style>
        body {
            margin: 0;
            font-family: 'Cairo', sans-serif;
            background: #f4f6f9;
            direction: rtl;
        }
        #controls {
            background: linear-gradient(135deg, #007bff, #0056b3);
            padding: 15px;
            color: white;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            position: relative;
            z-index: 1000;
        }
        h2 {
            margin-bottom: 15px;
            font-size: 1.4rem;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
        }
        .input-group {
            position: relative;
            display: inline-block;
            width: 85%;
            max-width: 350px;
            margin: 8px;
        }
        input {
            padding: 12px 15px;
            width: 100%;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }
        input:focus {
            outline: none;
            box-shadow: 0 0 0 3px rgba(0,123,255,0.3);
            transform: translateY(-2px);
        }
        input::placeholder {
            color: #aaa;
            font-size: 14px;
        }
        button {
            padding: 12px 30px;
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 10px 5px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }
        button:hover {
            background: linear-gradient(135deg, #218838, #1e9e8a);
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.25);
        }
        button:active {
            transform: translateY(0);
        }
        #map {
            width: 100%;
            height: 70vh;
        }
        #location {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(255,255,255,0.45);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 16px;
            color: #000;
            z-index: 9999;
            backdrop-filter: blur(4px);
            max-width: 60%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        #recenter {
            position: absolute;
            bottom: 18px;
            right: 12px;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: rgba(255,255,255,0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 6px 14px rgba(0,0,0,0.18);
            cursor: pointer;
            z-index: 9999;
            font-size: 18px;
        }
        #recenter:active {
            transform: scale(0.98);
        }
        #status {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(255,255,255,0.75);
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 9999;
        }
        .suggestions {
            position: absolute;
            background: #fff;
            border: 1px solid #ddd;
            max-height: 160px;
            overflow-y: auto;
            z-index: 2000;
            width: 100%;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: none;
        }
        .suggestions div {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s ease;
        }
        .suggestions div:hover {
            background: #e3f2fd;
        }
        .suggestions div:last-child {
            border-bottom: none;
        }
        .hint {
            font-size: 12px;
            color: #e0e0e0;
            margin-top: 8px;
            font-style: italic;
        }
        @media (max-width: 768px) {
            .input-group {
                width: 90%;
            }
            input {
                font-size: 16px;
            }
            h2 {
                font-size: 1.2rem;
            }
            #map {
                height: 65vh;
            }
        }
    </style>
</head>
<body>
    <div id="controls">
        <h2>ğŸš— Ø®Ø±ÙŠØ·ØªÙƒ Ø§Ù„Ø°ÙƒÙŠØ© ÙÙŠ Ù…ØµØ±</h2>
        <div class="input-group">
            <input id="start" placeholder="Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© (Ù…Ø«Ù„Ø§Ù‹: Ù†ÙƒÙ„Ø§ØŒ Ø§Ù„Ù…Ù†ÙŠØ§)">
            <div id="start-suggestions" class="suggestions"></div>
        </div>
        <div class="input-group">
            <input id="end" placeholder="Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ù†Ù‡Ø§ÙŠØ© (Ù…Ø«Ù„Ø§Ù‹: Ø£Ù… Ø¯ÙŠÙ†Ø§Ø±ØŒ Ø§Ù„Ø¬ÙŠØ²Ø©)">
            <div id="end-suggestions" class="suggestions"></div>
        </div>
        <button onclick="useCurrentLocation()">Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ</button>
        <button onclick="getRoute()">Ø§Ø­Ø³Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±</button>
        <div class="hint">Ø§ÙƒØªØ¨ Ø§Ø³Ù… Ø§Ù„Ù‚Ø±ÙŠØ© Ø£Ùˆ Ø§Ù„Ù…Ø¯ÙŠÙ†Ø© Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ù…ÙˆÙ‚Ø¹Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠ</div>
    </div>
    <div id="location">Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: <span id="address">Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹...</span></div>
    <div id="map"></div>
    <div id="recenter" title="Ø§Ù„Ø¹ÙˆØ¯Ø© Ù„Ù„Ù…ÙˆÙ‚Ø¹">â—</div>
    <div id="status">ÙˆØ¶Ø¹: Ø§Ù†ØªØ¸Ø§Ø± Ø§Ù„Ù…ÙˆÙ‚Ø¹ â€” Ø¯Ù‚Ø© Ù…Ø³ØªÙ‡Ø¯ÙØ© â‰¤ 3 Ù…</div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
    <script>
        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø®Ø±ÙŠØ·Ø© Ø¹Ù„Ù‰ Ù…ØµØ±
        const map = L.map('map', { zoomControl: true }).setView([30.0444, 31.2357], 15);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„ØªØªØ¨Ø¹
        let marker = null;
        let lastPos = null;
        let nextPos = null;
        let animStart = null;
        let animDur = 1000;
        let userHasPanned = false;
        let autoCenter = true;
        let routingControl = null;
        let routePath = null;
        let traversedPath = null;
        let currentLocation = null;

        // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù…ÙˆÙ‚Ø¹
        const POLL_INTERVAL_MS = 1000;
        const TARGET_ACCURACY_M = 3;
        const REVERSE_GEOCODE_MIN_MOVE = 3;

        // Ø¹Ù†Ø§ØµØ± ÙˆØ§Ø¬Ù‡Ø©
        const locLabel = document.getElementById('location');
        const recenterBtn = document.getElementById('recenter');
        const statusEl = document.getElementById('status');
        const startInput = document.getElementById('start');
        const endInput = document.getElementById('end');

        // Ø¯Ø§Ù„Ø© Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§ÙØ© (Haversine)
        function haversineMeters(a, b) {
            const R = 6371000;
            const toRad = v => v * Math.PI / 180;
            const dLat = toRad(b.lat - a.lat);
            const dLon = toRad(b.lon - a.lon);
            const lat1 = toRad(a.lat);
            const lat2 = toRad(b.lat);
            const sinDlat = Math.sin(dLat / 2), sinDlon = Math.sin(dLon / 2);
            const A = sinDlat * sinDlat + sinDlon * sinDlon * Math.cos(lat1) * Math.cos(lat2);
            const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1 - A));
            return R * C;
        }

        // Ø¯Ø§Ù„Ø© reverse geocoding
        async function reverseGeocodeIfNeeded(lat, lon) {
            try {
                if (!reverseGeocodeIfNeeded.last || haversineMeters(reverseGeocodeIfNeeded.last, { lat, lon }) > REVERSE_GEOCODE_MIN_MOVE) {
                    reverseGeocodeIfNeeded.last = { lat, lon };
                    locLabel.innerHTML = 'Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: <span id="address">Ø¬Ø§Ø±ÙŠ Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ø´Ø§Ø±Ø¹...</span>';
                    const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=20&addressdetails=1&accept-language=ar`;
                    const res = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' } });
                    if (!res.ok) throw new Error('Ø®Ø·Ø£ ÙÙŠ Ø®Ø¯Ù…Ø© Ø§Ù„Ø¹Ù†ÙˆØ§Ù†');
                    const data = await res.json();
                    const addr = data.address || {};
                    const street = addr.road || addr.pedestrian || addr.footway || addr.cycleway || addr.highway || '';
                    const building = addr.house_number ? (' ' + addr.house_number) : '';
                    const area = addr.suburb || addr.neighbourhood || addr.village || '';
                    const city = addr.city || addr.town || addr.county || addr.state || '';
                    let name = '';
                    if (street) name = street + building;
                    if (!name && area) name = area;
                    if (!name && city) name = city;
                    if (!name) name = data.display_name || 'Ù…ÙˆÙ‚Ø¹ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ';
                    if (name.length > 80) name = name.slice(0, 80) + '...';
                    locLabel.innerHTML = `Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: <span id="address">${name}</span>`;
                    // ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ø§Ù„ÙŠ Ù„Ø§Ø³ØªØ®Ø¯Ø§Ù…Ù‡ ÙƒØ¨Ø¯Ø§ÙŠØ©
                    currentLocation = { lat, lon, name };
                }
            } catch (e) {
                console.error('reverse geocode failed', e);
                locLabel.innerHTML = 'Ù…ÙˆÙ‚Ø¹ÙŠ Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ: <span id="address">Ø®Ø·Ø£ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ø³Ù… Ø§Ù„Ù…ÙˆÙ‚Ø¹</span>';
            }
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆØ¶Ø¹ Ù…Ø¹ Ø­Ø±ÙƒØ© Ù†Ø§Ø¹Ù…Ø©
        function animate() {
            requestAnimationFrame(animate);
            if (!lastPos || !nextPos) return;
            const now = performance.now();
            const t = Math.min(1, (now - animStart) / animDur);
            const lat = lastPos.lat + (nextPos.lat - lastPos.lat) * t;
            const lon = lastPos.lon + (nextPos.lon - lastPos.lon) * t;

            if (!marker) {
                marker = L.marker([lat, lon]).addTo(map);
            } else {
                marker.setLatLng([lat, lon]);
            }

            if (autoCenter) {
                map.setView([lat, lon], map.getZoom(), { animate: true, pan: { duration: 0.9 } });
            }

            // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹
            if (routePath && lastPos && t >= 1) {
                updateTraversedPath({ lat, lon });
            }

            if (t >= 1) {
                lastPos = { ...nextPos, time: Date.now() };
                nextPos = null;
            }
        }
        animate();

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø³Ø§Ø± Ø§Ù„Ù…Ù‚Ø·ÙˆØ¹
        function updateTraversedPath(currentPos) {
            if (!routePath) return;
            const routeCoords = routePath.getLatLngs();
            let closestPointIndex = 0;
            let minDistance = Infinity;

            // Ø¥ÙŠØ¬Ø§Ø¯ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³Ø§Ø±
            routeCoords.forEach((point, index) => {
                const dist = haversineMeters(currentPos, { lat: point.lat, lon: point.lng });
                if (dist < minDistance) {
                    minDistance = dist;
                    closestPointIndex = index;
                }
            });

            // Ø¥Ø°Ø§ ÙƒØ§Ù†Øª Ø§Ù„Ù…Ø³Ø§ÙØ© Ø¥Ù„Ù‰ Ø£Ù‚Ø±Ø¨ Ù†Ù‚Ø·Ø© Ø£Ù‚Ù„ Ù…Ù† 10 Ø£Ù…ØªØ§Ø±ØŒ Ø§Ø¹ØªØ¨Ø±Ù‡Ø§ Ù…Ù‚Ø·ÙˆØ¹Ø©
            if (minDistance < 10) {
                const traversedCoords = routeCoords.slice(0, closestPointIndex + 1);
                const remainingCoords = routeCoords.slice(closestPointIndex);

                if (traversedPath) {
                    map.removeLayer(traversedPath);
                }
                traversedPath = L.polyline(traversedCoords, { color: '#00ff00', weight: 6, opacity: 0.8 }).addTo(map);
                routePath.setLatLngs(remainingCoords);
            }
        }

        // Ø¯Ø§Ù„Ø© Ø¬Ù„Ø¨ Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
        async function fetchSuggestions(query, suggestionBox) {
            if (query.length < 2) {
                suggestionBox.style.display = 'none';
                suggestionBox.innerHTML = '';
                return;
            }
            try {
                const searchQuery = query.includes('Ù…ØµØ±') ? query : `${query}, Ù…ØµØ±`;
                const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&countrycodes=eg&limit=7&accept-language=ar`;
                const response = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' } });
                const data = await response.json();
                suggestionBox.innerHTML = '';
                if (data.length === 0) {
                    suggestionBox.style.display = 'none';
                    return;
                }
                data.forEach(place => {
                    const div = document.createElement('div');
                    const displayName = place.display_name.split(',').slice(0, 3).join(',');
                    div.textContent = displayName;
                    div.title = place.display_name;
                    div.onclick = () => {
                        const input = suggestionBox.previousElementSibling;
                        input.value = place.display_name;
                        suggestionBox.style.display = 'none';
                        suggestionBox.innerHTML = '';
                    };
                    suggestionBox.appendChild(div);
                });
                suggestionBox.style.display = 'block';
            } catch (error) {
                console.error('Error fetching suggestions:', error);
                suggestionBox.style.display = 'none';
            }
        }

        // Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ù…Ø¹ Ø§Ù„Ø§Ù‚ØªØ±Ø§Ø­Ø§Øª
        function setupInputWithSuggestions(inputId, suggestionsId) {
            const input = document.getElementById(inputId);
            const suggestions = document.getElementById(suggestionsId);
            let timeoutId;
            input.addEventListener('input', (e) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    fetchSuggestions(e.target.value, suggestions);
                }, 300);
            });
            document.addEventListener('click', (e) => {
                if (!input.contains(e.target) && !suggestions.contains(e.target)) {
                    suggestions.style.display = 'none';
                }
            });
            input.addEventListener('focus', () => {
                if (input.value.length >= 2) {
                    fetchSuggestions(input.value, suggestions);
                }
            });
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') e.preventDefault();
            });
        }

        setupInputWithSuggestions('start', 'start-suggestions');
        setupInputWithSuggestions('end', 'end-suggestions');

        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ
        function useCurrentLocation() {
            if (currentLocation) {
                startInput.value = currentLocation.name;
                document.getElementById('start-suggestions').style.display = 'none';
            } else {
                statusEl.textContent = 'Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø­Ø§Ù„ÙŠ Ø¨Ø¹Ø¯';
            }
        }

        // ØªØ­ÙˆÙŠÙ„ Ø§Ù„Ø§Ø³Ù… Ø¥Ù„Ù‰ Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª
        async function geocode(place) {
            if (!place.trim()) throw new Error('ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø§Ø³Ù… Ø§Ù„Ù…ÙƒØ§Ù†');
            const searchPlace = place.includes('Ù…ØµØ±') ? place : `${place}, Ù…ØµØ±`;
            const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchPlace)}&countrycodes=eg&limit=1&accept-language=ar`;
            const response = await fetch(url, { headers: { 'User-Agent': 'EgyptSmartMap/1.0' } });
            const data = await response.json();
            if (data.length === 0) {
                throw new Error(`Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ "${place}". Ø¬Ø±Ø¨ Ø§Ø³Ù…Ù‹Ø§ Ø£ÙƒØ«Ø± ØªØ­Ø¯ÙŠØ¯Ù‹Ø§.`);
            }
            return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
        }

        // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±
        async function getRoute() {
            const startVal = startInput.value.trim();
            const endVal = endInput.value.trim();
            if (!startVal || !endVal) {
                statusEl.textContent = 'ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ù†Ù‚Ø·ØªÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ© ÙˆØ§Ù„Ù†Ù‡Ø§ÙŠØ©';
                return;
            }
            try {
                statusEl.textContent = 'â³ Ø¬Ø§Ø±ÙŠ ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª...';
                let startCoords, endCoords;
                if (startVal === currentLocation?.name) {
                    startCoords = [currentLocation.lat, currentLocation.lon];
                } else {
                    startCoords = await geocode(startVal);
                }
                endCoords = await geocode(endVal);
                statusEl.textContent = 'ğŸš— Ø¬Ø§Ø±ÙŠ Ø­Ø³Ø§Ø¨ Ø£ÙØ¶Ù„ Ù…Ø³Ø§Ø±...';
                if (routingControl) {
                    map.removeControl(routingControl);
                }
                if (traversedPath) {
                    map.removeLayer(traversedPath);
                    traversedPath = null;
                }
                routingControl = L.Routing.control({
                    waypoints: [
                        L.latLng(startCoords[0], startCoords[1]),
                        L.latLng(endCoords[0], endCoords[1])
                    ],
                    router: L.Routing.osrmv1({
                        serviceUrl: 'https://router.project-osrm.org/route/v1/',
                        profile: 'driving'
                    }),
                    lineOptions: {
                        styles: [{ color: '#ff0000', weight: 6, opacity: 0.8 }]
                    },
                    addWaypoints: false,
                    draggableWaypoints: false,
                    fitSelectedRoutes: true,
                    showAlternatives: false,
                    createMarker: function() { return null; }
                }).addTo(map);
                setTimeout(removeRoutingPanels, 100);
                routingControl.on('routesfound', e => {
                    routePath = e.routes[0].coordinates ? L.polyline(e.routes[0].coordinates.map(c => [c.lat, c.lng]), { color: '#ff0000', weight: 6, opacity: 0.8 }).addTo(map) : null;
                    const summary = e.routes[0].summary;
                    const dist = (summary.totalDistance / 1000).toFixed(1);
                    const time = Math.round(summary.totalTime / 60);
                    statusEl.innerHTML = `âœ… <strong>Ø§Ù„Ù…Ø³Ø§ÙØ©:</strong> ${dist} ÙƒÙ… | <strong>Ø§Ù„Ø²Ù…Ù† Ø§Ù„Ù…ØªÙˆÙ‚Ø¹:</strong> ${time} Ø¯Ù‚ÙŠÙ‚Ø©`;
                    removeRoutingPanels();
                });
                routingControl.on('routingerror', e => {
                    statusEl.textContent = 'âŒ Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø­Ø³Ø§Ø¨ Ø§Ù„Ù…Ø³Ø§Ø±. Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.';
                });
            } catch (err) {
                console.error(err);
                statusEl.innerHTML = `âŒ <strong>Ø®Ø·Ø£:</strong> ${err.message}`;
            }
        }

        // Ø¥Ø®ÙØ§Ø¡ Ù„ÙˆØ­Ø§Øª Ø§Ù„Ø§ØªØ¬Ø§Ù‡Ø§Øª
        function removeRoutingPanels() {
            const panels = document.querySelectorAll('.leaflet-routing-container');
            panels.forEach(p => {
                p.style.display = 'none';
                p.remove();
            });
        }

        // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¨ÙŠØ§Ù†Ø§Øª GPS
        function handleNewGPS(lat, lon, accuracy) {
            statusEl.textContent = `Ø¯Ù‚Ø©: ${Math.round(accuracy)} Ù… â€” Ù…Ø³ØªÙ‡Ø¯ÙØ© â‰¤ ${TARGET_ACCURACY_M} Ù…`;
            const incoming = { lat, lon };
            if (!lastPos) {
                lastPos = { ...incoming, time: Date.now() };
                nextPos = { ...incoming };
                animStart = performance.now();
                if (autoCenter) map.setView([lat, lon], 17);
                reverseGeocodeIfNeeded(lat, lon);
                return;
            }
            const dist = haversineMeters(lastPos, incoming);
            animStart = performance.now();
            animDur = POLL_INTERVAL_MS;
            nextPos = { ...incoming };
            if (dist > REVERSE_GEOCODE_MIN_MOVE) reverseGeocodeIfNeeded(lat, lon);
        }

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØªØ¨Ø¹
        function startTracking() {
            if (!('geolocation' in navigator)) {
                statusEl.textContent = 'Ø§Ù„Ù…ØªØµÙØ­ Ù„Ø§ ÙŠØ¯Ø¹Ù… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ù…ÙˆÙ‚Ø¹';
                return;
            }
            try {
                navigator.geolocation.watchPosition(pos => {
                    const { latitude, longitude, accuracy } = pos.coords;
                    if (accuracy <= TARGET_ACCURACY_M) {
                        handleNewGPS(latitude, longitude, accuracy);
                    }
                }, err => {
                    console.error('watchPosition error', err);
                    statusEl.textContent = 'ØªØ¹Ø°Ø± Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…ÙˆÙ‚Ø¹ (ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø³Ù…Ø§Ø­)';
                }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
                setInterval(() => {
                    navigator.geolocation.getCurrentPosition(pos => {
                        const { latitude, longitude, accuracy } = pos.coords;
                        if (accuracy <= TARGET_ACCURACY_M) {
                            handleNewGPS(latitude, longitude, accuracy);
                        }
                    }, err => {}, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
                }, POLL_INTERVAL_MS);
            } catch (e) {
                console.error(e);
            }
        }

        // Ø£Ø­Ø¯Ø§Ø« Ø¥Ø¶Ø§ÙÙŠØ©
        recenterBtn.addEventListener('click', () => {
            autoCenter = true;
            userHasPanned = false;
            if (lastPos) map.setView([lastPos.lat, lastPos.lon], 17, { animate: true });
        });
        map.on('movestart', () => {
            userHasPanned = true;
            autoCenter = false;
        });
        document.addEventListener('keypress', e => {
            if (e.key === 'Enter') getRoute();
        });

        // Ø¨Ø¯Ø¡ Ø§Ù„ØªØªØ¨Ø¹ ÙÙˆØ±Ø§Ù‹
        startTracking();
    </script>
</body>
</html>
