<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>خريطة مصر الذكية - التتبع والمسارات</title>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.css" />
<style>
  html, body { 
    height: 100%; 
    margin: 0; 
    padding: 0; 
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f4f6f9;
    direction: rtl;
  }

  #controls {
    background: linear-gradient(135deg, #007bff, #0056b3);
    padding: 15px;
    color: white;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    position: relative;
    z-index: 1000;
  }

  h2 {
    margin-bottom: 20px;
    font-size: 1.4rem;
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
  }

  .input-group {
    position: relative;
    display: inline-block;
    width: 85%;
    max-width: 350px;
    margin: 8px;
  }

  input {
    padding: 12px 15px;
    width: 100%;
    border: none;
    border-radius: 8px;
    font-size: 16px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.1);
    transition: all 0.3s ease;
  }

  input:focus {
    outline: none;
    box-shadow: 0 0 0 3px rgba(0,123,255,0.3);
    transform: translateY(-2px);
  }

  input::placeholder { 
    color: #aaa; 
    font-size: 14px;
  }

  button {
    padding: 12px 30px;
    background: linear-gradient(135deg, #28a745, #20c997);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 16px;
    font-weight: bold;
    margin-top: 10px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: all 0.3s ease;
  }

  button:hover { 
    background: linear-gradient(135deg, #218838, #1e9e8a);
    transform: translateY(-2px);
    box-shadow: 0 6px 12px rgba(0,0,0,0.25);
  }

  button:active {
    transform: translateY(0);
  }

  #map {
    width: 100%;
    height: 75vh;
  }

  #status {
    text-align: center;
    padding: 12px;
    font-weight: bold;
    background: white;
    color: #333;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    min-height: 20px;
    transition: all 0.3s ease;
  }

  .suggestions {
    position: absolute;
    background: #fff;
    border: 1px solid #ddd;
    max-height: 160px;
    overflow-y: auto;
    z-index: 2000;
    width: 100%;
    border-radius: 0 0 8px 8px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    display: none;
  }

  .suggestions div {
    padding: 10px 15px;
    cursor: pointer;
    border-bottom: 1px solid #f0f0f0;
    transition: background 0.2s ease;
  }

  .suggestions div:hover {
    background: #e3f2fd;
  }

  .suggestions div:last-child {
    border-bottom: none;
  }

  .hint {
    font-size: 12px;
    color: #e0e0e0;
    margin-top: 8px;
    font-style: italic;
  }

  /* شريط اسم الموقع الشفاف */
  #location {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(255,255,255,0.85);
    padding: 8px 12px;
    border-radius: 8px;
    font-family: "Cairo", sans-serif;
    font-size: 16px;
    color: #000;
    z-index: 9999;
    backdrop-filter: blur(4px);
    max-width: 60%;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  /* زر العودة للموقع (دائرة صغيرة وجميلة) */
  #recenter {
    position: absolute;
    bottom: 18px;
    right: 12px;
    width: 44px;
    height: 44px;
    border-radius: 50%;
    background: rgba(255,255,255,0.95);
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 6px 14px rgba(0,0,0,0.18);
    cursor: pointer;
    z-index: 9999;
    font-size: 18px;
  }
  #recenter:active { transform: scale(0.98); }

  /* مؤشر سريع للاتصال/الحالة */
  #gps-status {
    position: absolute;
    bottom: 12px;
    left: 12px;
    background: rgba(255,255,255,0.75);
    padding: 6px 10px;
    border-radius: 8px;
    font-family: "Cairo", sans-serif;
    font-size: 13px;
    z-index: 9999;
  }

  /* زر تحديد موقعي */
  #use-my-location {
    background: linear-gradient(135deg, #ff9800, #f57c00);
    margin-left: 10px;
  }

  #use-my-location:hover {
    background: linear-gradient(135deg, #f57c00, #e65100);
  }

  /* تحسينات للجوال */
  @media (max-width: 768px) {
    .input-group {
      width: 90%;
    }
    input {
      font-size: 16px;
    }
    h2 {
      font-size: 1.2rem;
    }
    #location {
      max-width: 70%;
      font-size: 14px;
    }
  }
</style>
</head>
<body>

<div id="controls">
  <h2>🚗 خريطتك الذكية في مصر - التتبع والمسارات</h2>
  <div class="input-group">
    <input id="start" placeholder="اكتب اسم البداية (مثلاً: نكلا، المنيا)">
    <div id="start-suggestions" class="suggestions"></div>
  </div>
  <div class="input-group">
    <input id="end" placeholder="اكتب اسم النهاية (مثلاً: أم دينار، الجيزة)">
    <div id="end-suggestions" class="suggestions"></div>
  </div>
  <button onclick="getRoute()">احسب المسار</button>
  <button id="use-my-location" onclick="useMyLocation()">استخدم موقعي الحالي</button>
  <div class="hint">يمكنك استخدام موقعك الحالي أو كتابة اسم المكان</div>
</div>

<div id="status">🔍 ابدأ بكتابة اسم المكان في الحقل أعلاه</div>
<div id="map"></div>

<div id="location">موقعي الحقيقي: <span id="address">جاري تحديد الموقع...</span></div>
<div id="recenter" title="العودة للموقع">◎</div>
<div id="gps-status">وضع: انتظار الموقع — دقة مستهدفة ≤ 3 م</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-routing-machine@latest/dist/leaflet-routing-machine.js"></script>
<script>
// إعداد الخريطة على مصر
const map = L.map('map').setView([26.8206, 30.8025], 6);
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

let routingControl = null;
let currentRoute = null;
const statusDiv = document.getElementById('status');
const gpsStatusDiv = document.getElementById('gps-status');

// إخفاء لوحات الاتجاهات الجانبية
const removeRoutingPanels = () => {
    const panels = document.querySelectorAll('.leaflet-routing-container');
    panels.forEach(p => {
        p.style.display = 'none';
        p.remove();
    });
};

// دالة جلب اقتراحات محسنة مع تأخير للبحث
async function fetchSuggestions(query, suggestionBox) {
    if (query.length < 2) {
        suggestionBox.style.display = 'none';
        suggestionBox.innerHTML = '';
        return;
    }

    try {
        // إضافة "مصر" تلقائياً للبحث
        const searchQuery = query.includes('مصر') ? query : `${query}, مصر`;
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}&countrycodes=eg&limit=7&accept-language=ar`;
        
        const response = await fetch(url, { 
            headers: { 'User-Agent': 'EgyptSmartMap/1.0' } 
        });
        const data = await response.json();

        suggestionBox.innerHTML = '';
        
        if (data.length === 0) {
            suggestionBox.style.display = 'none';
            return;
        }

        data.forEach(place => {
            const div = document.createElement('div');
            // تقصير النص لعرض أفضل
            const displayName = place.display_name.split(',').slice(0, 3).join(',');
            div.textContent = displayName;
            div.title = place.display_name; // عرض الاسم الكامل عند التمرير
            div.onclick = () => {
                const input = suggestionBox.previousElementSibling;
                input.value = place.display_name;
                suggestionBox.style.display = 'none';
                suggestionBox.innerHTML = '';
            };
            suggestionBox.appendChild(div);
        });
        
        suggestionBox.style.display = 'block';
    } catch (error) {
        console.error('Error fetching suggestions:', error);
        suggestionBox.style.display = 'none';
    }
}

// ربط الاقتراحات مع تحسينات الأداء
function setupInputWithSuggestions(inputId, suggestionsId) {
    const input = document.getElementById(inputId);
    const suggestions = document.getElementById(suggestionsId);
    let timeoutId;

    input.addEventListener('input', (e) => {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
            fetchSuggestions(e.target.value, suggestions);
        }, 300); // تأخير 300ms لتقليل طلبات API
    });

    // إخفاء الاقتراحات عند النقر خارجها
    document.addEventListener('click', (e) => {
        if (!input.contains(e.target) && !suggestions.contains(e.target)) {
            suggestions.style.display = 'none';
        }
    });

    // إظهار الاقتراحات عند التركيز إذا كان هناك نص
    input.addEventListener('focus', () => {
        if (input.value.length >= 2) {
            fetchSuggestions(input.value, suggestions);
        }
    });
}

// تهيئة الحقول
setupInputWithSuggestions('start', 'start-suggestions');
setupInputWithSuggestions('end', 'end-suggestions');

// تحويل الاسم إلى إحداثيات مع تحسينات
async function geocode(place) {
    if (!place.trim()) throw new Error('يرجى إدخال اسم المكان');
    
    // إضافة "مصر" تلقائياً إذا لم تكن موجودة
    const searchPlace = place.includes('مصر') ? place : `${place}, مصر`;
    const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchPlace)}&countrycodes=eg&limit=1&accept-language=ar`;
    
    const response = await fetch(url, { 
        headers: { 'User-Agent': 'EgyptSmartMap/1.0' } 
    });
    const data = await response.json();
    
    if (data.length === 0) {
        throw new Error(`لم يتم العثور على "${place}". جرب اسمًا أكثر تحديدًا.`);
    }
    
    return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
}

// استخدام الموقع الحالي كنقطة بداية
function useMyLocation() {
    if (lastPos) {
        document.getElementById('start').value = 'موقعي الحالي';
        statusDiv.textContent = '✅ تم تعيين موقعك الحالي كنقطة بداية';
    } else {
        statusDiv.textContent = '❌ لم يتم تحديد موقعك بعد. يرجى الانتظار...';
    }
}

// حساب المسار مع تحسينات
async function getRoute() {
    const startVal = document.getElementById('start').value.trim();
    const endVal = document.getElementById('end').value.trim();

    if (!startVal || !endVal) {
        alert('يرجى إدخال نقطتي البداية والنهاية');
        return;
    }

    try {
        statusDiv.textContent = '⏳ جاري تحديد الإحداثيات...';
        
        let startCoords;
        if (startVal === 'موقعي الحالي' && lastPos) {
            startCoords = [lastPos.lat, lastPos.lon];
        } else {
            startCoords = await geocode(startVal);
        }
        
        const endCoords = await geocode(endVal);

        statusDiv.textContent = '🚗 جاري حساب أفضل مسار...';

        if (routingControl) {
            map.removeControl(routingControl);
        }

        routingControl = L.Routing.control({
            waypoints: [
                L.latLng(startCoords[0], startCoords[1]),
                L.latLng(endCoords[0], endCoords[1])
            ],
            router: L.Routing.osrmv1({
                serviceUrl: 'https://router.project-osrm.org/route/v1/',
                profile: 'driving'
            }),
            lineOptions: {
                styles: [{ color: '#ff0000', weight: 6, opacity: 0.8 }]
            },
            addWaypoints: false,
            draggableWaypoints: false,
            fitSelectedRoutes: true,
            showAlternatives: false,
            createMarker: function() { return null; }
        }).addTo(map);

        // إخفاء اللوحات الجانبية بعد إضافة المسار
        setTimeout(removeRoutingPanels, 100);

        routingControl.on('routesfound', e => {
            const summary = e.routes[0].summary;
            const dist = (summary.totalDistance / 1000).toFixed(1);
            const time = Math.round(summary.totalTime / 60);
            statusDiv.innerHTML = `✅ <strong>المسافة:</strong> ${dist} كم | <strong>الزمن المتوقع:</strong> ${time} دقيقة`;
            removeRoutingPanels();
            
            // حفظ المسار الحالي لتتبع التقدم
            currentRoute = e.routes[0];
            
            // بدء تتبع التقدم على المسار
            startRouteTracking();
        });

        routingControl.on('routingerror', e => {
            statusDiv.textContent = '❌ حدث خطأ في حساب المسار. حاول مرة أخرى.';
        });

    } catch (err) {
        console.error(err);
        statusDiv.innerHTML = `❌ <strong>خطأ:</strong> ${err.message}`;
    }
}

// متغيرات تتبع الموقع
let marker = null;
let lastPos = null;
let nextPos = null;
let animStart = null;
let animDur = 1000;
let userHasPanned = false;
let autoCenter = true;
let routeProgress = null;
let routeTracking = false;

// عناصر واجهة المستخدم
const locLabel = document.getElementById('location');
const recenterBtn = document.getElementById('recenter');

// إعدادات الموقع
const POLL_INTERVAL_MS = 1000;
const TARGET_ACCURACY_M = 3;
const REVERSE_GEOCODE_MIN_MOVE = 3;

// دالة حساب المسافة التقريبية بين نقطتين بالأمتار (Haversine)
function haversineMeters(a, b){
    const R = 6371000;
    const toRad = v => v * Math.PI/180;
    const dLat = toRad(b.lat-a.lat);
    const dLon = toRad(b.lon-a.lon);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const sinDlat = Math.sin(dLat/2), sinDlon = Math.sin(dLon/2);
    const A = sinDlat*sinDlat + sinDlon*sinDlon * Math.cos(lat1)*Math.cos(lat2);
    const C = 2 * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
    return R * C;
}

// دالة للـ reverse geocoding باستخدام Nominatim (OpenStreetMap)
async function reverseGeocodeIfNeeded(lat, lon){
    try{
        if (!reverseGeocodeIfNeeded.last || haversineMeters(reverseGeocodeIfNeeded.last, {lat,lon}) > REVERSE_GEOCODE_MIN_MOVE){
            reverseGeocodeIfNeeded.last = {lat,lon};
            locLabel.innerHTML = 'موقعي الحقيقي: <span id="address">جاري جلب اسم الشارع...</span>';
            const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=20&addressdetails=1&accept-language=ar`;
            const res = await fetch(url, { headers: { 'User-Agent': 'MyMapApp/1.0' } });
            if (!res.ok) throw new Error('خطأ في خدمة العنوان');
            const data = await res.json();
            const addr = data.address || {};
            const street = addr.road || addr.pedestrian || addr.footway || addr.cycleway || addr.highway || '';
            const building = addr.house_number ? (' ' + addr.house_number) : '';
            const area = addr.suburb || addr.neighbourhood || addr.village || '';
            const city = addr.city || addr.town || addr.county || addr.state || '';
            let name = '';
            if (street) name = street + building;
            if (!name && area) name = area;
            if (!name && city) name = city;
            if (!name) name = data.display_name || 'موقع غير معروف';

            // ضع الاسم مُقتَصراً اذا طويل جداً
            if (name.length > 80) name = name.slice(0,80) + '...';
            locLabel.innerHTML = `موقعي الحقيقي: <span id="address">${name}</span>`;
        }
    }catch(e){
        console.error('reverse geocode failed', e);
        locLabel.innerHTML = 'موقعي الحقيقي: <span id="address">خطأ في جلب اسم الموقع</span>';
    }
}

// تحديث الموضع — نقوم بتسلسل حركي ناعم بين lastPos و nextPos
function animate(){
    requestAnimationFrame(animate);
    if (!lastPos || !nextPos) return;
    const now = performance.now();
    const t = Math.min(1, (now - animStart) / animDur);
    const lat = lastPos.lat + (nextPos.lat - lastPos.lat) * t;
    const lon = lastPos.lon + (nextPos.lon - lastPos.lon) * t;

    // تحديث marker
    if (!marker){
        marker = L.circleMarker([lat, lon], {
            radius: 10,
            fillColor: "#0078ff",
            color: "#0056b3",
            weight: 2,
            opacity: 1,
            fillOpacity: 0.8
        }).addTo(map);
    } else {
        marker.setLatLng([lat, lon]);
    }

    // إذا المستخدم لم يزلّ الخريطة (لم يقم بالتحريك) أو وضعنا autoCenter true
    if (autoCenter) {
        map.setView([lat, lon], map.getZoom(), { animate: true, pan: { duration: 0.9 } });
    }

    // عندما تكتمل الحركة، نقّدم lastPos
    if (t >= 1){
        lastPos = { ...nextPos, time: Date.now() };
        nextPos = null;
        
        // إذا كان هناك مسار نشط، تتبع التقدم
        if (routeTracking && currentRoute) {
            updateRouteProgress(lastPos.lat, lastPos.lon);
        }
    }
}
animate();

// عند الضغط على زر العودة، نعيد تفعيل التتبع ومركز الخريطة
recenterBtn.addEventListener('click', ()=>{
    autoCenter = true;
    userHasPanned = false;
    if (lastPos) map.setView([lastPos.lat, lastPos.lon], 17, { animate:true });
});

// كشف حدث تحريك الخريطة من قبل المستخدم
map.on('movestart', ()=>{ userHasPanned = true; autoCenter = false; });

// دالة لتلقي بيانات GPS وتعيينها كـ nextPos (تعمل كل ثانية)
function handleNewGPS(lat, lon, accuracy){
    gpsStatusDiv.textContent = `دقة: ${Math.round(accuracy)} م — مستهدفة ≤ ${TARGET_ACCURACY_M} م`;

    const incoming = { lat: lat, lon: lon };
    if (!lastPos){
        // لأول مرة
        lastPos = { ...incoming, time: Date.now() };
        nextPos = { ...incoming };
        animStart = performance.now();
        // نوقف تحريك الخريطة فقط لو autoCenter true
        if (autoCenter) map.setView([lat, lon], 17);
        reverseGeocodeIfNeeded(lat, lon);
        return;
    }

    // لو المسافة صغيرة جداً، لا نغير reverse geocode
    const dist = haversineMeters(lastPos, incoming);

    // ضبط مدة التحريك بناءً على الفرق الزمني؛ لكن نبقيها ≈ 1000ms لتوافق الطلب
    animStart = performance.now();
    animDur = POLL_INTERVAL_MS;

    // نضع nextPos لتتحرك السلسة
    nextPos = { ...incoming };

    // نطلب اسم المكان لو تحركنا أكثر من حد
    if (dist > REVERSE_GEOCODE_MIN_MOVE) reverseGeocodeIfNeeded(lat, lon);
}

// بدء تتبع المسار
function startRouteTracking() {
    if (!currentRoute) return;
    
    routeTracking = true;
    routeProgress = {
        completedSegments: [],
        currentSegmentIndex: 0,
        totalDistance: currentRoute.summary.totalDistance,
        completedDistance: 0
    };
    
    statusDiv.innerHTML += ' | <strong>جاري تتبع المسار...</strong>';
}

// تحديث تقدم المسار
function updateRouteProgress(lat, lon) {
    if (!currentRoute || !routeTracking) return;
    
    const currentPoint = L.latLng(lat, lon);
    let closestSegmentIndex = -1;
    let minDistance = Infinity;
    
    // البحث عن أقرب مقطع في المسار
    for (let i = 0; i < currentRoute.coordinates.length - 1; i++) {
        const segmentStart = L.latLng(currentRoute.coordinates[i]);
        const segmentEnd = L.latLng(currentRoute.coordinates[i + 1]);
        
        // حساب المسافة من النقطة الحالية إلى المقطع
        const distance = pointToSegmentDistance(currentPoint, segmentStart, segmentEnd);
        
        if (distance < minDistance) {
            minDistance = distance;
            closestSegmentIndex = i;
        }
    }
    
    // إذا وجدنا مقطع قريب (ضمن 50 متر)
    if (closestSegmentIndex !== -1 && minDistance < 50) {
        // تحديث المقطع الحالي إذا تقدمنا
        if (closestSegmentIndex > routeProgress.currentSegmentIndex) {
            routeProgress.currentSegmentIndex = closestSegmentIndex;
            
            // تحديث المسافة المكتملة
            let completed = 0;
            for (let i = 0; i < closestSegmentIndex; i++) {
                completed += haversineMeters(
                    currentRoute.coordinates[i],
                    currentRoute.coordinates[i + 1]
                );
            }
            routeProgress.completedDistance = completed;
            
            // تحديث حالة المسار
            const progressPercent = (routeProgress.completedDistance / routeProgress.totalDistance * 100).toFixed(1);
            statusDiv.innerHTML = `✅ <strong>المسافة:</strong> ${(routeProgress.totalDistance/1000).toFixed(1)} كم | <strong>التقدم:</strong> ${progressPercent}%`;
            
            // تغيير لون الأجزاء المكتملة من المسار
            updateRouteColors();
        }
    }
}

// حساب المسافة من نقطة إلى مقطع خطي
function pointToSegmentDistance(point, segmentStart, segmentEnd) {
    const A = point.lat - segmentStart.lat;
    const B = point.lng - segmentStart.lng;
    const C = segmentEnd.lat - segmentStart.lat;
    const D = segmentEnd.lng - segmentStart.lng;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) {
        param = dot / lenSq;
    }

    let xx, yy;

    if (param < 0) {
        xx = segmentStart.lat;
        yy = segmentStart.lng;
    } else if (param > 1) {
        xx = segmentEnd.lat;
        yy = segmentEnd.lng;
    } else {
        xx = segmentStart.lat + param * C;
        yy = segmentStart.lng + param * D;
    }

    const dx = point.lat - xx;
    const dy = point.lng - yy;
    
    return Math.sqrt(dx * dx + dy * dy) * 111320; // تحويل إلى أمتار
}

// تحديث ألوان المسار بناءً على التقدم
function updateRouteColors() {
    if (!routingControl || !routeProgress) return;
    
    // الحصول على عنصر المسار
    const routeElement = document.querySelector('.leaflet-routing-line');
    if (!routeElement) return;
    
    // في تطبيق حقيقي، سنحتاج إلى طريقة أكثر تعقيداً لتحديث ألوان المسار
    // هذه مجرد فكرة مبسطة
    const progressPercent = routeProgress.completedDistance / routeProgress.totalDistance;
    
    // يمكننا هنا تغيير لون المسار المكتمل
    // في تطبيق حقيقي، سنحتاج إلى تقسيم المسار إلى أجزاء وتلوين كل جزء على حدة
}

// محاولة استخدام watchPosition (أسرع وأدق عند توفره)، لكن سنستخدم poll أيضاً كل 1 ثانية
let watchId = null;
function startTracking(){
    if (!('geolocation' in navigator)){
        gpsStatusDiv.textContent = 'المتصفح لا يدعم تحديد الموقع';
        return;
    }

    // أفضل إعداد لطلب دقة عالية — لكن الدقة الحقيقية تعتمد على الجهاز وإشارة GPS
    try{
        watchId = navigator.geolocation.watchPosition(pos => {
            const { latitude, longitude, accuracy } = pos.coords;
            // نعطي أولوية لتحديثات watchPosition
            handleNewGPS(latitude, longitude, accuracy);
        }, err => {
            console.error('watchPosition error', err);
            gpsStatusDiv.textContent = 'تعذر الحصول على موقع (تأكد من السماح)';
        }, { enableHighAccuracy: true, maximumAge: 0, timeout: 10000 });
    }catch(e){
        console.error(e);
    }

    // poll احتياطي كل 1 ثانية لضمان التحديث إذا لم ترسل watchPosition بسرعة كافية
    setInterval(()=>{
        navigator.geolocation.getCurrentPosition(pos => {
            const { latitude, longitude, accuracy } = pos.coords;
            handleNewGPS(latitude, longitude, accuracy);
        }, err => {
            // تجاهل أخطاء مؤقتة
        }, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
    }, POLL_INTERVAL_MS);
}

// ابدأ التتبع فوراً
startTracking();

// دعم الضغط على Enter
document.addEventListener('keypress', e => { 
    if (e.key === 'Enter') getRoute(); 
});

// إخفاء الاقتراحات عند التمرير
map.whenReady(() => {
    statusDiv.textContent = '🌍 الخريطة جاهزة. ابدأ بإدخال الأماكن!';
});

// منع إعادة تحميل الصفحة عند الضغط على Enter في الحقول
document.getElementById('start').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') e.preventDefault();
});
document.getElementById('end').addEventListener('keypress', function(e) {
    if (e.key === 'Enter') e.preventDefault();
});
</script>

</body>
</html>
